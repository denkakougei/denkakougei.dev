---
import { Image } from "astro:assets";
import { load } from "cheerio";
import katex from "katex";
import { bundledLanguages, codeToHtml } from "shiki";
import { addCopyButton } from "shiki-transformer-copy-button";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getWorkDetail, getWorks } from "../../lib/microcms";
import { formatDateJST } from "../../utils/date/formatDateJST";
import "../../styles/content.css";

export async function getStaticPaths() {
  const { contents } = await getWorks();
  return contents.map((work) => ({
    params: { id: work.id },
    props: { work },
  }));
}

const { id } = Astro.params;
if (!id) {
  throw new Error("Work ID is required");
}
const work = await getWorkDetail(id);

const $ = load(work.content || "");
const promises: Promise<void>[] = [];

let htmlContent = $.html();

// MathJAX記法の処理（ディスプレイ数式: $$...$$）
const displayMathRegex = /\$\$([^$]+)\$\$/g;
htmlContent = htmlContent.replace(
  displayMathRegex,
  (match: string, math: string) => {
    try {
      const cleanMath = math.replace(/<br\s*\/?>/gi, "");
      return katex.renderToString(cleanMath, { displayMode: true });
    } catch (error) {
      console.warn("KaTeX display math error:", error);
      return match;
    }
  },
);

// MathJAX記法の処理（インライン数式: $...$）
const inlineMathRegex = /\$([^$\n]+)\$/g;
htmlContent = htmlContent.replace(
  inlineMathRegex,
  (match: string, math: string) => {
    try {
      return katex.renderToString(math, { displayMode: false });
    } catch (error) {
      console.warn("KaTeX inline math error:", error);
      return match;
    }
  },
);

// 処理済みのHTMLを再度cheerioでロード
const $preProcessedHtml = load(htmlContent);

// コードブロックの処理
$preProcessedHtml("pre").each((_, elm) => {
  const codeElement = $preProcessedHtml(elm).find("code");
  const lang =
    codeElement.attr("class")?.replace("language-", "") || "plaintext";
  const code = codeElement.text();

  if (lang === "tex" || lang === "latex") return;

  if (lang === "mermaid") {
    const mermaidWrapper = $preProcessedHtml('<div class="mermaid"></div>');
    mermaidWrapper.text(code);
    $preProcessedHtml(elm).replaceWith(mermaidWrapper);
    return;
  }
  const supportedLang = bundledLanguages[lang as keyof typeof bundledLanguages]
    ? lang
    : "plaintext";
  const promise = codeToHtml(code, {
    lang: supportedLang,
    theme: "dark-plus",
    transformers: [addCopyButton({ toggle: 3000 })], // コピーボタンを付与
  }).then((highlighted) => {
    $preProcessedHtml(elm).replaceWith(highlighted);
  });

  promises.push(promise);
});

await Promise.all(promises);
const formatedHtml = $preProcessedHtml.html();
---

<BaseLayout title={work.title}>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous" />
  <div class="mainContentInner">
    <div class="header">
      <h1 class="title">{work.title}</h1>
      {
        work.eyecatch && (
          <picture class="eyecatch">
            <Image
                src={`${work.eyecatch.url}?fm=webp&fit=fill&fill-color=dde0e4&w=840&h=441`}
                alt={work.title}
                class="eyecatch"
                width={work.eyecatch?.width || 840}
                height={work.eyecatch?.height || 441}
                format="webp"
            />
          </picture>
        )
      }
    </div>
    <div class="content" set:html={formatedHtml} />
    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
      const mermaidNodes = document.querySelectorAll(".content .mermaid");
      if (mermaidNodes.length > 0) {
        mermaid.initialize({ startOnLoad: false });
        mermaid.run({ nodes: Array.from(mermaidNodes) });
      }
    </script>
    <nav class="breadcrumb">
      <a href="/works">← 作品一覧に戻る</a>
    </nav>
  </div>
</BaseLayout>

<style>
  .mainContentInner {
    box-sizing: border-box;
    display: block grid;
    grid-template-columns: 100%;
    gap: var(--spacing-8);
    inline-size: 100%;
    max-width: var(--container-size-md);
  }
</style>